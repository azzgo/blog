# "运行和部署"
date: 2015-05-31 11:28:32
categories:
- 文档翻译
tags:
- tornado
- python
---
因为Tornado本身提供HttpServer服务，运行和部署Tornado应用和其他的Python Web框架有点不同。你需要书写一个`main()`方法启动服务，而不是配置一个WSGI容器来载入应用。
<!--more-->

```python
def main():
	app = make_app()
	app.listen(8888)
	IOLoop.cureent().start()

if __name__ == '__main__':
	main()
```

配置你的操作系统或者运行一个管理器来执行这个程序。注意可能需要提供每个处理器打开文件的限制(为了避免"Too many open files"错误)。为了提高这个限制（比如设置为50000），可以使用ulimit命令，或者修改`/etc/security/limits.conf`或者在你的supervisord配置文件中设置`minfds`.

## 处理器和端口

因为Python GIL(Global Interpreter Lock)，有必要运行多个Python程序以便重复利用多核CPU。通常最好的是一个CPU对应运行一个程序。

Tornado包含内建的多线程模式，可以一次启动多个程序。这需要在标准的main方法中做些小修改：

```python
def main():
	app = make_app()
	server = tornado.httpserver.HTTPServer(app)
	server.bind(8888)
	server.start(0)		# forks one process per cpu
	IOLoop.current().start()
```

这种是启动多个进程并共享同一端口的最简单的方式之一了，但这样有一些限制。第一每个子进程拥有它自己的IOLoop，因此在fork前没有任何方式可以访问到全局的IOLoop实例（即使是间接的方式）。第二，这样子很难实现热更新。最后，因为所有进程共享同一端口，更加难以单独监控。

对于复杂的部署环境，推荐单独启动每一个进程，并让每一个进程监听不同的端口。有进程组特性的[supervisord](http://www.supervisord.org/)可以很好的管理这点。当每一个进程都是有不同的端口，就需要用负载均衡器（比如HAProxy或者nginx）来对外提供一个单一访问地址。

## 在一个负载均衡器后运行程序

当在像是nginx这种负载均很器后启动程序，推荐给`HTTPServer`容器传入`xheaders=True`参数。这告诉Tornado使用像是`X-Real-IP`的HTTP头获取用户的IP地址，而不会将所有流量都标记成均衡器的IP。

这有个最简的nginx配置文件，和我们在FriendFeed使用的配置类似。它假设nginx和Tornado服务运行在同一个机器上，并且四个Tornado服务运行在端口8000-8003上：

```
user nginx;
worker_processes 1;

error_log /var/log/nginx/error.log;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    # Enumerate all the Tornado servers here
    upstream frontends {
        server 127.0.0.1:8000;
        server 127.0.0.1:8001;
        server 127.0.0.1:8002;
        server 127.0.0.1:8003;
    }

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    access_log /var/log/nginx/access.log;

    keepalive_timeout 65;
    proxy_read_timeout 200;
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    gzip on;
    gzip_min_length 1000;
    gzip_proxied any;
    gzip_types text/plain text/html text/css text/xml
               application/x-javascript application/xml
               application/atom+xml text/javascript;

    # Only retry if there was a communication error, not a timeout
    # on the Tornado server (to avoid propagating "queries of death"
    # to all frontends)
    proxy_next_upstream error;

    server {
        listen 80;

        # Allow file uploads
        client_max_body_size 50M;

        location ^~ /static/ {
            root /var/www;
            if ($query_string) {
                expires max;
            }
        }
        location = /favicon.ico {
            rewrite (.*) /static/favicon.ico;
        }
        location = /robots.txt {
            rewrite (.*) /static/robots.txt;
        }

        location / {
            proxy_pass_header Server;
            proxy_set_header Host $http_host;
            proxy_redirect off;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Scheme $scheme;
            proxy_pass http://frontends;
        }
    }
}
```

## 静态文件和文件缓存

你可以在Tornado中指定`static_path`设定来提供静态文件访问。

```python
settings = {
	"static_path": os.path.join(os.path.dirname(__file__), "static"),
	"cookie_secret": "__TODO:_GENTERATE_YOUR_OWN_RANDOM_VALUE_HERE__",
	"login_url": "/login",
	"xsrf_cookies": True，
}

application = tornado.web.Application([
	(r"/", MainHandler),
	(r"/login", LoginHandler),
	(r"/(apple-touch-icon\.png)", tornado.web.StaticFileHandler,
		dict(path=settings['static_path'])),
], **settings)
```

所有以`/static/`开头的请求会自动响应对应静态目录下的文件。比如，`http://localhost:8888/static/foo.png`会从指定的静态目录中提供`foo.png`。我们也自动转换`/robots.txt`和`/favicon.ico`到静态目录下的对应文件（即使他们不以`/static`前缀)。

上面的设置中，我们配置Tornado使用`StaticFileHandler`从根提供`apple-touch-icon.png`文件，尽管它实际上在静态文件目录里。（正是正则表达式中的捕获组告诉`StaticFileHandler`请求的文件名；重新将匹配的捕获组作为参数传给handler）你可以对`sitemap.xml`做同样的事，让它从根下载入。当然你也可以直接在HTML文件中使用正确的`<link />`标签指定`apple-touch-icon.png`文件。

为了提升性能，通常让浏览器缓存静态资源是个好主意，这样浏览器就捕获发出不必要的`IF-Modified-Since`或者`Etag`请求这种可能阻塞页面渲染的请求了。Tornado通过_静态内容版本_支持这项功能。

为了能够使用这点特性，在你的目标中使用`static_url`方法而不是在HTML中键入静态文件目录地址的URL：

```html
<html>
	<head>
		<title>FriendFeed - {{ _("Home") }}</title>
	</head>
	<body>
		<div><img src="{{ static_url("images/logo.png") }}"/></div>
	</body>
</html>
```

`static_url()`方法会将这个相对路径转化为看起来像是`/static/imgages/logo.png?v=aae54`的路径格式。这个`v`参数是一个`logo.png`内容的一个hash，让Tornado服务可以发出一个缓存头给用户浏览器，用户浏览器会缓存无限期缓存内容。

因为`v`参数基于文件内容，如果更改了一个文件并重启了你的服务，它会发送一个新的`v`值，因此用户浏览器会自动的获取新文件。如果文件内容没有改变，浏览器会继续使用本地缓存的副本而不会到服务器去检查更新，这样提升渲染性能效果非常明显。
 
在生产环境中，你可能需要使用一个优化过的静态服务器来提供静态文件托管服务，比如nginx。你可以配置任何的web服务使用`static_url()`识别版本标签，并且相应的设置缓存头。这里有一份相关部分的nginx配置文件：

```
location /static/ {
	root /var/friendfeed/static;
	if ($query_string) {
		expires max;
	}
}
```


## 调试模式和自动重载

如果你将`debug=True`传给`Application`构造器，app会运行在调试/开发模式。这个模式中，几个开发中方便的特性会被开启（每一个也是独立的标志，同时指定，独立的标志优先）。

- `autoreload=True`：App会监测源文件的所有变化，在变化时会自动重新载入。这可以减少开发中手动重启服务的时间。然而，某些失败（比如导入时的语法错误）可能能让会让服务死掉，调试模式当前并不能从中恢复。
- `compile_template_cache=False`：模板不会被缓存。
- `static_hash_cache=False`静态文件hash（使用了`static_url`方法的）不会被缓存。
- `serve_traceback=True`：当一个在`RequestHandler`中的异常没有被捕获，一个包含stack trace的错误页面会被生成出来。

自动重载模式和`HttpServer`的多进程模式不兼容。在你使用自动重载模式的时候，你不能在`HttpSever.start`参数上使用除了1之外的值(也不能调用`tornado.process.fork_processes`）。

调试模式中的自动重载特性也可以使用`tornado.autoreload`。结合两者可以提供额外的稳定性：设置`autoreload=True`的话会自动在运行时检查变化，以`python -m tornado.autoreload myserver.py`启动的app会在启动时捕获语法错误或者其他的错误。

重载会遗失所有的Python解释权的命令行参数（比如`-u`）因为它使用`sys.executable`和`sys.argv`重新执行Python。另外，更改这些变量会导致重载的行为错误。

某些平台（包含Windows和Mac OSX），程序不能内更新，所有当代码变化被侦测到时，旧服务会推出然后启动一个新的服务。

## WSGI 和 Google App Engine

Tornado设计为自运行的，不需要WSGI容器。然而，在某些环境下（比如Google App Engine），只有WSGI环境，应用不能运行在它自个的服务上。这种情形下，Tornado支持一种受限制模式可以让Tornado的功能的一个子集运行在仅仅支持WSGI的环境中。这种特性不允许使用协程，`@asynchronous`修饰符，`AsyncHttpClient`，`auth`模块，和WebSockets。

你可以使用`tornado.wsgi.WSGIAdapter`将一个Tornado应用转化为一个WSGI应用。这个例子中，配置你的WSGI容器找到`application`对象：

```python
import tornado.web
import tornado.wsgi

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hello, world")

tornado_app = tornado.web.Application([
    (r"/", MainHandler),
])
application = tornado.wsgi.WSGIAdapter(tornado_app)
```

查看[app engine 应用的例子](https://github.com/tornadoweb/tornado/tree/stable/demos/appengine)了解更多Tornado在AppEngine上的特性。
