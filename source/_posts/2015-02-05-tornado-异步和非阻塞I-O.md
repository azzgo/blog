title: tornado-异步和非阻塞I/O
date: 2015-02-05 17:19:06
categories:
- 文档翻译
tags:
- tornado
- python
- async
- non-block
---

实时 Web 服务要求对每一个用户都有一个长存活的空闲连接存在. 在传统的同步服务器中, 通过为每一位用户分配一个线程实现. 这个方案非常昂贵.

为了最小化并发的消费, Tornado 使用单线程事件循环模式. 这意味着所有的代码必须用异步喝非阻塞的方式运行, 因为一次只能有一个操作被激活.

异步和非阻塞两个术语非常接近, 经常他们也互换着使用, 但是他们并不是指同一件东西.

<!--more-->

## 阻塞

一个阻塞的函数在它返回前的某件事情发生之前会一直等待. 一个函数可能由于多种原因阻塞: 网络I/O, 磁盘I/O, 互锁等等. 事实上, 所有的函数在运行和使用CPU时都有或多或少的阻塞(一个极端的例子说明下CPU阻塞和其他类型的阻塞一样严重, 考虑下像是 brypt 这类的hash函数被设计为需要使用数百毫秒的CPU时间, 比通常的网络和磁盘访问更消耗时间)

一个函数可能在某些方面阻塞而其他方面阻塞. 例如, _tornado.httpclient_ 默认配置在 DNS 解析上阻塞, 但在其他网络访问不阻塞(可以使用 _ThreadedResolver_ 或者恰当配置基于 _libcurl_ 的 _tornado.curl_ httpclient_ 减轻这种阻塞). 在 Tornado 中我们主要谈论网络I/O的阻塞, 尽管所有阻塞的影响都减到最低.

## 异步

一个异步函数在它执行玩之前就返回了, 这将导致某些工作会在背景中执行直到应用中将来某些动作被触发(和总是在返回之前执行完所有的事同步执行的函数不同). 有多种异步的接口:

- 回调参数
- 然后一个占位符( __Future__, Promise, Deferred)
- 传递到一个队列
- 回调注册(比如 POSIX 信号)

不管使用哪种类型的接口, 异步函数和调用它的调用者的交互也不一样. 没有好的方法使同步函数异步的方式运行, 而且对调用者透明(类似 gevent 的系统使用轻量级线程提供媲美异步系统的性能, 但是他们并没有让代码异步执行)

